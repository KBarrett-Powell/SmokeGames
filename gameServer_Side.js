

// Raw (game logic only) Class
class Game {

    // Setting up instance variables that store game state...
    constructor(io) {

      this.io = io;
      this.Users = []; // --> Stores the games user's state including their username and score.
      this.gUsers = []; // --> Stores the socket objects and their respective names, which is used when removing a user from the game, on disconnect.



        // Player position variables
        this.player_1 = 0;
        this.player_2 = 0;

        // Ball position variables
        this.ball_x = 300; // Initially set to horizontal center
        this.ball_y = 200; // Initially set to vertical center

        // Ball velocity variables
        this.vel_x = 7// Initially set to one
        this.vel_y = 7; // Initially set to one
      }


showUsers() {
  console.log("Number of players in the lobby: " + this.gUsers.length);
  if (this.gUsers.length == 2) { // Sets the maximum number of users needed to start the game, this should really be dynamic instead of hardcoded (user choice?)
    this.startGame(); // When number of users required has been met, the game is started and game logic starts execution.z
    }
  }


addUsertoGame(socketId, name) { // When a new user has connected to a particular lobby, we add thre socketId and associcated name for reference in
      // various methods.
      this.Users.push(socketId);
      this.Users.push(name);
    }

    InformUserOfLobby(socket) {
      socket.emit("test", this.roomId);
    }


addUser(playerName) { // A new users state is strored in a user variable which is then added to the list of users.
  var user = {
    name: playerName,
    score: 0
  }

  this.gUsers.push(user);
  this.updateUsers();
}


// Method to remove a user from the list of users when they have disconnnected
removeUser(user) {

    for (var i = 0; i < this.gUsers.length; i++) {
        // Iterate through list of users until correct user is identified...
        if (user == this.gUsers[i].name) {
            // Removing user entry from list of users...
            this.gUsers.splice(i, 1);
            console.log("User: " + user + " has left the game");
            this.updateUsers();


            console.log("");
            console.log("PLAYER " + user + " HAS LEFT THE GAME...");
            console.log("");
        };
    };

    if (this.gUsers.length == 1) {
        this.endGame();
    }
}


updateUsers() {

    // Broadcast all the user names of the users that are in the game to all of the users...
    console.log("Users present in the game: " + this.gUsers.length);
    //this.io.sockets.in(this.roomId).emit("users", this.gUsers);
};


// This will cause the client loading screen to be hidden and the first question of the game generated by the updateQuestion() method
startGame() {
    //this.io.sockets.in(this.roomId).emit("gameStarted", true);
    //this.updateQuestion();  This needs to call dummyStart()
}


/*This method is triggered in the case when there is only one user left in the game and so they win by default.
IMPORTANT: This method will need to redirect the user back to the game page when the game ends so that they are not just stuck on the game
page. In addition when the game is over the game instance needs it summary data written to the SQL database and it will then need to be removed
from the myGameInstances array.*/
endGame() {

    console.log("endGame() is called");
    var destination = '/home.html';
    //this.io.sockets.in(this.roomId).emit("gameEnded",destination);
}


getUserScore(username){

  for(var user in this.gUsers){
    // get corresponding usernames score
  }
}


getSide(socket, num){
  socket.emit("playerNumber", num);
}


collideWithPaddle(){

  if((this.player_1) < this.ball_y && (this.player_1 + 100) > this.ball_y && (this.ball_x <= 20)){

    this.vel_x = -(this.vel_x * 1.05)//* (1.025 + Math.random(1));

    console.log("paddle 1 new vel " + this.vel_x);
    this.vel_y = this.vel_y  + Math.floor(Math.random() * 2 + 1);//* (1.025 + Math.random(1));
  }

else if((this.player_2) < this.ball_y && (this.player_2 + 100) > this.ball_y && (this.ball_x >= 570)){

  this.vel_x = -(this.vel_x * 1.05); //;* (1.025 + Math.random(1));
  this.vel_y = this.vel_y = this.vel_y  + Math.floor(Math.random() * 2 + 1);
  console.log("paddle 2 new vel " + this.vel_x);

  }
}


setPlayer(number, position){

  console.log("NO!");

  if(number == 1){
    this.player_1 = position;
    console.log("yes");
  }

  else if(number == 2){
    this.player_2 = position;
      console.log("yes");
  }

}


collideWithWall(){

  if( this.ball_y >= 400 || this.ball_y <= 0){
    this.vel_y = - this.vel_y
  }

  else if(this.ball_x >= 600 || this.ball_x <= 0){

      // When there is a collision with a wall, update score.

      if(this.ball_x >= 600){

        this.ball_x = 300; // Reset to horizontal center
        this.ball_y = 200; // Reset set to vertical center

        this.vel_x = 7; // Reset x-axis velocity the the original
        this.vel_y = 7; // Reset y-axis velocity the the original

        this.gUsers[0].score+=1;

        console.log("score for player 1: " + this.gUsers[0].score)

      } // If ball hits right wall, award player 1 a point

      if(this.ball_x <= 0){


        this.ball_x = 300; // Reset to horizontal center
        this.ball_y = 200; // Reset set to vertical center

        this.vel_x = 7; // Reset x-axis velocity the the original
        this.vel_y = 7; // Reset y-axis velocity the the original

        this.gUsers[1].score+=1;

        console.log("score for player 2: " + this.gUsers[1].score)

      } // If ball hits left wall, award player 2 a point

          this.vel_x = -this.vel_x;
        }

      }


dummyStart(){
  var self = this;
  setInterval(function(){

      self.collideWithWall();
      self.collideWithPaddle();
      console.log("paddle 1-2 new vel " + self.vel_x);
      self.ball_x = self.ball_x + self.vel_x;
      self.ball_y = self.ball_y + self.vel_y;

      self.io.sockets.emit("drawBall", {"x": self.ball_x, "y": self.ball_y, "y1": self.player_1, "y2": self.player_2});
  },
   (1000/30));  // FPS set to 30
 }
}

module.exports = Game;
